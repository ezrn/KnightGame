using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class InventoryManager : MonoBehaviour
{
    [Header("Controls")]
    [SerializeField] private PlayerControls controls; //reference to controls(for "R")

    [Header("Bag UI")]
    [SerializeField] private Image mainBagImage; //item icon in the main slot
    [SerializeField] private Image prevBagImage; //item icon in the prev slot
    [SerializeField] private Image nextBagImage; // item icon in the next slot
    [SerializeField] private CanvasGroup prevBagSlot; //backround icon for the actual prev slot
    [SerializeField] private CanvasGroup nextBagSlot; //backround icon for the actual next slot
    [SerializeField] private TMP_Text descriptionText; // description for main bag item
    [SerializeField] private TMP_Text stackCountText; //shows item count for main bag slot

    private readonly List<InventoryEntry> bagItems = new();

    private int currentBagIndex = -1; //start at undefined index(no items)

    public static InventoryManager Instance { get; private set; } //get the bag inventory from anywhere

    private void Awake()
    {
        Instance = this;
        UpdateBagUI();
    }

    public void AddItem(Item item, int quantity = 1) //when anything calls AddItem it will default to stack size 1. overloadable in future
    {
        AddBagItem(item, quantity);
    }

    private void Update()
    {
        HandleBagScrollInput();
        HandleBagUseInput();
    }

    #region  Bag
    private void AddBagItem(Item item, int qty)
    {
        // allow stacking by item.id, item ID's are autogenerated based on currently taken ones
        InventoryEntry entry = bagItems.Find(b => b.item.id == item.id);
        if (entry != null)
        {
            entry.quantity += qty;
        }
        else
        {
            bagItems.Add(new InventoryEntry(item, qty));
            if (currentBagIndex == -1) currentBagIndex = 0;
        }
        UpdateBagUI();
    }

    private void HandleBagScrollInput()
    {
        if (bagItems.Count == 0) return;

        float delta = Input.mouseScrollDelta.y;
        if (Mathf.Approximately(delta, 0f)) return;

        int dir = delta > 0 ? 1 : -1; // up = next
        currentBagIndex = (currentBagIndex + dir + bagItems.Count) % bagItems.Count;
        UpdateBagUI();
    }

    private void HandleBagUseInput()
    {
        if (bagItems.Count == 0) return;

        if (Input.GetKeyDown(controls.UseBagItemKey))
        {
            InventoryEntry entry = bagItems[currentBagIndex];
            var usage = entry.item.worldPrefab.GetComponent<IItemUsage>();
            if (usage != null) usage.OnUse();

            // consumable types are removed when used
            if (entry.item.type == ItemType.Consumable)
            {
                entry.quantity--;
                if (entry.quantity <= 0)
                {
                    bagItems.RemoveAt(currentBagIndex);
                    if (bagItems.Count == 0)
                        currentBagIndex = -1;
                    else
                        currentBagIndex %= bagItems.Count;
                }
                UpdateBagUI();
            }
        }
    }

    private void UpdateBagUI()
    {
        if (bagItems.Count == 0)
        {
            mainBagImage.enabled = false;
            prevBagSlot.alpha = 0;
            nextBagSlot.alpha = 0;
            descriptionText.text = "";
            stackCountText.text = "";
            return;
        }

        mainBagImage.enabled = true;

        // helpers that wrap around to beginning if it goes over
        int Prev(int i) => (i - 1 + bagItems.Count) % bagItems.Count;
        int Next(int i) => (i + 1) % bagItems.Count;

        InventoryEntry main = bagItems[currentBagIndex];
        mainBagImage.sprite = main.item.icon;
        descriptionText.text = main.item.description;
        stackCountText.text = main.quantity > 1 ? main.quantity.ToString() : "";

        // prev / next slots
        if (bagItems.Count == 1)
        {
            prevBagSlot.alpha = 0;
            nextBagSlot.alpha = 0;
        }
        else if (bagItems.Count == 2)
        {
            // duplicate icon if there are only two items(prev and next are filled by it)
            prevBagSlot.alpha = 1;
            nextBagSlot.alpha = 1;

            prevBagImage.sprite = bagItems[Prev(currentBagIndex)].item.icon;
            nextBagImage.sprite = bagItems[Prev(currentBagIndex)].item.icon;
        }
        else // hide prev and next bag slots if there is only one item
        {
            prevBagSlot.alpha = 1;
            nextBagSlot.alpha = 1;

            prevBagImage.sprite = bagItems[Prev(currentBagIndex)].item.icon;
            nextBagImage.sprite = bagItems[Next(currentBagIndex)].item.icon;
        }
    }

    #endregion
}
